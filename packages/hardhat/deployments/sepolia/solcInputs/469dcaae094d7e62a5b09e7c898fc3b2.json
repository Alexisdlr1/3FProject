{
  "language": "Solidity",
  "sources": {
    "contracts/FFFBusiness.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.2 <0.9.0;\n\ncontract FFFBusiness {\n    address payable private _businessWallet;\n    uint128 private _totalMembers;\n    uint128 private _totalActiveMembers;\n\n    uint128 private _minAmountToTransfer = 10000000000000000;  // Currently is a wei unit (0.01 Ether)\n    uint8 constant private _MAX_TICKETS = 3; // NOTE: this feature remains to be seen\n    \n    uint8 private _refundTierOne = 5;\n    uint8 private _refundTierTwo = 10;\n    uint8 private _refundTierThree = 15;\n    uint8 private _refundTierFour = 20;\n    uint8 private _refundTierFive = 25;\n\n    uint8 private _qualifyToImproveRank = 3; // NOTE: this feature remains to be seen\n\n    enum Ranks {\n        Sapphire,   // 0\n        Pearl,      // 1\n        Ruby,       // 2\n        Emerald,    // 3\n        Diamond     // 4\n    }\n\n    struct Member {\n        address payable memberWallet;\n        bool isActive;\n        uint balance;\n        Ranks rank;\n    }\n\n    struct WithdrawTicket {\n        address payable to;\n        uint128 requestedAmount;\n        uint32 requestDate;\n        bool isPaid;\n    }\n\n    mapping(address => Member) private members;\n    mapping(address => address[]) private enrolled;\n    mapping(address => WithdrawTicket[]) private withdrawals; // NOTE: this feature remains to be seen\n\n    modifier onlyBusiness() {\n        require(msg.sender == _businessWallet, \"Error: Not the business\");\n        _;\n    }\n\n    modifier onlyActiveMember() {\n        require(members[msg.sender].isActive, \"Member not active\");\n        _;\n    }\n\n    modifier onlyActiveMemberStruct(Member memory _currentMember){\n        require(_currentMember.isActive, \"Member not active\");\n        _;\n    }\n\n    modifier onlyActiveMemberAddress(address _currentMember){\n        require(members[_currentMember].isActive, \"Member not active\");\n        _;\n    }\n\n    modifier checkMemberBalance(uint _amount) {\n        require(members[msg.sender].balance >= _amount, \"Insufficient balance\");\n        _;\n    }\n\n    modifier checkMemberBalanceStruct(Member memory _currentMember, uint _amount) {\n        require(_currentMember.balance >= _amount, \"Insufficient balance\");\n        _;\n    }\n\n    modifier checkContractBalance(uint _amount) {\n        require(address(this).balance >= _amount, \"The contract doesn't have sufficient balance\");\n        _;\n    }\n\n    modifier checkValidAddress(address _recipient) {\n        require(_recipient != address(0), \"Invalid address\");\n        _;\n    }\n\n    modifier checkMinimumAmount() {\n        require(msg.value >= _minAmountToTransfer, \"Minimum amount is 0.01 Ethers\");\n        _;\n    }\n\n    modifier preventZeroAmount(uint _currentAmount) {\n        require(_currentAmount > 0, \"The amount must be greater than zero\");\n        _;\n    }\n\n    event Deposit(address indexed from, uint amount);\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event WithdrawalRequest(address indexed to, uint amount);\n    event Refund(address indexed to, uint amount);\n    \n    event BusinessWalletSet(address indexed oldBusinessWallet, address indexed newBusinessWallet);\n    event NewMember(address indexed member);\n    event NewRankReached(address indexed member, string rank);\n\n    constructor(address _mainWallet) {\n        // NOTE: modify constructor only for test deploy\n        // _businessWallet = payable(msg.sender);\n        _businessWallet = payable(_mainWallet);\n        _totalMembers = 0;\n        _totalActiveMembers = 0;\n        emit BusinessWalletSet(address(0), _businessWallet);\n        createMember(_businessWallet);\n    }\n\n    function deposit() public payable {}\n\n    function getTotalMembers() public view returns (uint) {\n        return _totalMembers;\n    }\n\n    function getTotalActiveMembers() public view returns (uint) {\n        return _totalActiveMembers;\n    }\n\n    function getBusinessWallet() public view returns (address) {\n        return _businessWallet;\n    }\n\n    function changeBusinessWallet(address _newBusinessWallet) public onlyBusiness {\n        emit BusinessWalletSet(_businessWallet, _newBusinessWallet);\n        _businessWallet = payable(_newBusinessWallet);\n    }\n\n    function getMemberBalance(address _currentMember) \n        public\n        view\n        onlyActiveMemberAddress(_currentMember)\n        returns(uint)\n    {\n        return members[_currentMember].balance;\n    }\n\n    function getMemberDetails(Member memory member)\n        public\n        pure\n        returns (\n            address, \n            bool,\n            uint,\n            Ranks\n        ) \n    {\n        require(member.isActive, \"Member not registered\");\n\n        return (\n            member.memberWallet,\n            member.isActive,\n            member.balance,\n            member.rank\n        );\n    }\n\n    function getMemberDetails(address _memberAddress)\n        public\n        view\n        returns (\n            address, \n            bool,\n            uint,\n            Ranks\n        ) \n    {\n        Member memory member = members[_memberAddress];\n        require(member.isActive, \"Member not registered\");\n\n        return (\n            member.memberWallet,\n            member.isActive,\n            member.balance,\n            member.rank\n        );\n    }\n\n    function addReferralToUpline(address _to, address _from)\n        public\n        onlyActiveMemberAddress(_to)\n        checkValidAddress(_to)\n    {\n        enrolled[_to].push(_from);\n        Member storage member = members[_to];\n        updateReferralRank(member, _to);\n    }\n\n    function memberEntrance(address _uplineAddress) \n        public\n        payable\n        checkMinimumAmount\n    {\n\n        if (!members[msg.sender].isActive) createMember(payable(msg.sender));\n\n        if (_uplineAddress != address(0)) addReferralToUpline(_uplineAddress, msg.sender);\n\n        depositMemeberFunds();\n    }\n\n    // NOTE: This is a provisional function for active members\n    function depositMemeberFunds()\n        public\n        payable\n        checkMinimumAmount\n    {\n        Member storage member = members[msg.sender];\n        member.balance += msg.value;\n        emit Deposit(msg.sender, msg.value);\n\n        uint8 refundPercentToMember = _getRefundPerRank(member);\n\n        uint refundToMember = _getRefundAmount(msg.value, refundPercentToMember);\n        uint refundToBusiness = msg.value - refundToMember;\n        require(refundToBusiness >= refundToMember, \"Failed transaction\");\n\n        _payment(_businessWallet, refundToBusiness);\n        _payment(payable(msg.sender), refundToMember);\n        emit Refund(msg.sender, refundToMember);\n    }\n\n    // NOTE: this feature remains to be seen\n    function withdrawalRequest(uint128 _requestedAmount)\n        public\n        preventZeroAmount(_requestedAmount)\n    {\n        Member memory currentMember = members[msg.sender];\n        require(currentMember.isActive, \"Member not active\");\n        require(currentMember.balance >= _requestedAmount, \"Insufficient balance\");\n        require(withdrawals[msg.sender].length <= _MAX_TICKETS, \"Error can't request more than 5 withdrawals\");\n\n        WithdrawTicket memory currentTicket = WithdrawTicket({\n            to: payable(msg.sender),\n            requestedAmount: _requestedAmount,\n            requestDate: uint32(block.timestamp),\n            isPaid: false\n        });\n        withdrawals[msg.sender].push(currentTicket);\n        emit WithdrawalRequest(msg.sender, _requestedAmount);\n    }\n\n    function payToMember(address _memberAddress, uint _amount)\n        public\n        onlyBusiness\n        preventZeroAmount(_amount)\n    {\n\n    }\n\n    function isCurrentlyActiveUser()\n        public\n        view\n        returns(bool)\n    {\n        return members[msg.sender].isActive;\n    }\n\n    function createMember(address payable _newMember)\n        internal\n        checkValidAddress(_newMember)\n    {\n        \n        Member storage newMember = members[_newMember];\n        newMember.memberWallet = _newMember;\n        newMember.isActive = true;\n        newMember.balance = 0;\n        newMember.rank = Ranks.Sapphire;\n\n        _totalMembers++;\n        _totalActiveMembers++;\n\n        emit NewMember(_newMember);\n    }\n\n    function _payment(address payable _to, uint _amount)\n        private\n        preventZeroAmount(_amount)\n    {\n        (bool sent, ) = _to.call{ value: _amount }(\"\");\n        require(sent, \"Failed transaction\");\n    }\n\n    function _getRefundAmount(uint _totalAmount, uint _refundPercent) private pure returns (uint) {\n        return (_totalAmount * _refundPercent) / 100;\n    }\n\n    function _getRefundPerRank(Member storage member)\n        private\n        view\n        returns (uint8) \n    {\n        if (member.rank == Ranks.Diamond) {\n            return _refundTierFive;\n        } \n        if (member.rank == Ranks.Emerald) {\n            return _refundTierFour;\n        } \n        if (member.rank == Ranks.Ruby) {\n            return _refundTierThree;\n        } \n        if (member.rank == Ranks.Pearl) {\n            return _refundTierTwo;\n        }\n\n        return _refundTierOne;\n    }\n\n    function _setNewRank(\n        Member storage currentMember,\n        Ranks newRank,\n        string memory nameRank\n        ) private\n    {\n        currentMember.rank = newRank;\n        emit NewRankReached(currentMember.memberWallet, nameRank);\n    }\n\n    function updateReferralRank(\n        Member storage currentMember,\n        address _currentMemberAddress\n        ) private \n    {\n        uint qualificationRank = enrolled[_currentMemberAddress].length / _qualifyToImproveRank;\n\n        if (qualificationRank == 5 && currentMember.rank != Ranks.Diamond) {\n            _setNewRank(\n                currentMember,\n                Ranks.Diamond,\n                \"Diamond\"\n            );\n        } else if (qualificationRank == 4 && currentMember.rank != Ranks.Emerald) {\n            _setNewRank(\n                currentMember,\n                Ranks.Emerald,\n                \"Emerald\"\n            );\n        } else if (qualificationRank == 3 && currentMember.rank != Ranks.Ruby) {\n            _setNewRank(\n                currentMember,\n                Ranks.Ruby,\n                \"Ruby\"\n            );\n        } else if (qualificationRank == 2 && currentMember.rank != Ranks.Pearl) {\n            _setNewRank(\n                currentMember,\n                Ranks.Pearl,\n                \"Pearl\"\n            );\n        }\n    }\n\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}